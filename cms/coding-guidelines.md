# ğŸ”® KAGAMI IRç®¡ç†ã‚»ãƒ³ã‚¿ãƒ¼ - ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ v2.0

## ğŸ“‹ ç›®æ¬¡
1. [ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ¦‚è¦](#ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ¦‚è¦)
2. [CSSè¦ç´„](#cssè¦ç´„)
3. [JavaScriptè¦ç´„](#javascriptè¦ç´„)
4. [å…±é€šãƒ‘ãƒ¼ãƒ„](#å…±é€šãƒ‘ãƒ¼ãƒ„)
5. [ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆè¦ç´„](#ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆè¦ç´„)
6. [ãƒ•ã‚¡ã‚¤ãƒ«æ§‹æˆè¦ç´„](#ãƒ•ã‚¡ã‚¤ãƒ«æ§‹æˆè¦ç´„)
7. [å‘½åè¦å‰‡](#å‘½åè¦å‰‡)
8. [ã‚³ãƒ¡ãƒ³ãƒˆè¦ç´„](#ã‚³ãƒ¡ãƒ³ãƒˆè¦ç´„)
9. [ğŸš€ é«˜åº¦ãªè¨­è¨ˆãƒ‘ã‚¿ãƒ¼ãƒ³](#é«˜åº¦ãªè¨­è¨ˆãƒ‘ã‚¿ãƒ¼ãƒ³)
10. [âš¡ ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–](#ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–)
11. [ğŸ”’ ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¦ä»¶](#ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¦ä»¶)
12. [ğŸ§ª ãƒ†ã‚¹ãƒˆæˆ¦ç•¥](#ãƒ†ã‚¹ãƒˆæˆ¦ç•¥)
13. [ğŸ“Š ãƒ­ã‚°ãƒ»ç›£è¦–æˆ¦ç•¥](#ãƒ­ã‚°ç›£è¦–æˆ¦ç•¥)
14. [ğŸ› ï¸ é–‹ç™ºãƒ„ãƒ¼ãƒ«é€£æº](#é–‹ç™ºãƒ„ãƒ¼ãƒ«é€£æº)
15. [ğŸ”„ ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°æŒ‡é‡](#ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°æŒ‡é‡)
16. [ğŸ“ˆ ä¿å®ˆæ€§ãƒ¡ãƒˆãƒªã‚¯ã‚¹](#ä¿å®ˆæ€§ãƒ¡ãƒˆãƒªã‚¯ã‚¹)

---

## ğŸ¯ ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ¦‚è¦

KAGAMI IRç®¡ç†ã‚»ãƒ³ã‚¿ãƒ¼ã¯ã€AIæŠ€è¡“ã‚’æ´»ç”¨ã—ãŸIRæ¥­å‹™æ”¯æ´ã‚·ã‚¹ãƒ†ãƒ ã§ã™ã€‚
çµ±ä¸€æ„Ÿã®ã‚ã‚‹é«˜å“è³ªãªãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’æä¾›ã™ã‚‹ãŸã‚ã€ä»¥ä¸‹ã®ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ã«å¾“ã£ã¦é–‹ç™ºã‚’è¡Œã„ã¾ã™ã€‚

**ãƒ–ãƒ©ãƒ³ãƒ‰ã‚«ãƒ©ãƒ¼ï¼š** KAGAMI Blue (#1a365d)  
**ãƒ‡ã‚¶ã‚¤ãƒ³ã‚·ã‚¹ãƒ†ãƒ ï¼š** CSSå¤‰æ•°ãƒ™ãƒ¼ã‚¹ã®ã‚¹ã‚±ãƒ¼ãƒ©ãƒ–ãƒ«ã‚·ã‚¹ãƒ†ãƒ   
**å¯¾å¿œãƒ–ãƒ©ã‚¦ã‚¶ï¼š** ãƒ¢ãƒ€ãƒ³ãƒ–ãƒ©ã‚¦ã‚¶ï¼ˆChrome, Firefox, Safari, Edgeï¼‰

---

## ğŸ¨ CSSè¦ç´„

### åŸºæœ¬åŸå‰‡
- **CSSå¤‰æ•°ã‚’æ´»ç”¨** ã—ãŸãƒ‡ã‚¶ã‚¤ãƒ³ã‚·ã‚¹ãƒ†ãƒ ã®çµ±ä¸€
- **BEMãƒ©ã‚¤ã‚¯ãªå‘½åè¦å‰‡** ã§ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®ç‹¬ç«‹æ€§ã‚’ä¿ã¤
- **ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–ãƒ•ã‚¡ãƒ¼ã‚¹ãƒˆ** ã§ãƒ¢ãƒã‚¤ãƒ«å¯¾å¿œã‚’é‡è¦–
- **ã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£** ã‚’è€ƒæ…®ã—ãŸå®Ÿè£…

### CSSå¤‰æ•°ã‚·ã‚¹ãƒ†ãƒ 

```css
:root {
    /* ã‚«ãƒ©ãƒ¼ãƒ‘ãƒ¬ãƒƒãƒˆ */
    --kagami-blue: #1a365d;
    --kagami-blue-light: #2d3748;
    --kagami-blue-dark: #0f1b2c;
    --trust-green: #48bb78;
    --alert-red: #f56565;
    --warning-orange: #ed8936;
    --info-blue: #4299e1;
    
    /* ã‚¹ãƒšãƒ¼ã‚·ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ  */
    --space-xs: 0.25rem;
    --space-sm: 0.5rem;
    --space-md: 1rem;
    --space-lg: 1.5rem;
    --space-xl: 2rem;
    --space-2xl: 3rem;
    --space-3xl: 4rem;
    
    /* ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ */
    --transition-fast: 0.15s ease-in-out;
    --transition-normal: 0.3s ease-in-out;
    --transition-slow: 0.5s ease-in-out;
}
```

### ã‚¯ãƒ©ã‚¹å‘½åè¦å‰‡

```css
/* âœ… æ¨å¥¨ - BEMãƒ©ã‚¤ã‚¯ãªå‘½å */
.header-navigation {}
.section-btn {}
.data-input-nav {}
.upload-area--active {}
.progress-bar__fill {}

/* âŒ éæ¨å¥¨ */
.redButton {}
.leftSidebar {}
.content1 {}
```

### ãƒ•ã‚¡ã‚¤ãƒ«æ§‹é€ 

```css
/* ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚³ãƒ¡ãƒ³ãƒˆã§æ•´ç† */
/* ===== ãƒªã‚»ãƒƒãƒˆãƒ»åŸºæœ¬è¨­å®š ===== */
/* ===== ãƒ˜ãƒƒãƒ€ãƒ¼ ===== */
/* ===== ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ ===== */
/* ===== ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚¨ãƒªã‚¢ ===== */
/* ===== ãƒ•ãƒƒã‚¿ãƒ¼ ===== */
/* ===== ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–å¯¾å¿œ ===== */
```

---

## âš¡ JavaScriptè¦ç´„

### åŸºæœ¬åŸå‰‡
- **ES6+** ã®è¨˜æ³•ã‚’æ´»ç”¨
- **é–¢æ•°å‹ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°** ã®ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã‚’é‡è¦–
- **ã‚°ãƒ­ãƒ¼ãƒãƒ«æ±šæŸ“ã‚’é¿ã‘ã‚‹** ãŸã‚ã®é©åˆ‡ãªã‚¹ã‚³ãƒ¼ãƒ—ç®¡ç†
- **ä¸€è²«æ€§ã®ã‚ã‚‹å‘½åè¦å‰‡** ã§ã‚³ãƒ¼ãƒ‰ã®å¯èª­æ€§ã‚’å‘ä¸Š

### å‘½åè¦å‰‡

```javascript
// âœ… æ¨å¥¨ - camelCase
const userName = 'ç”°ä¸­å¤ªéƒ';
const getCurrentUser = () => {};
const isUserLoggedIn = false;

// âœ… æ¨å¥¨ - å®šæ•°ã¯ UPPER_SNAKE_CASE
const API_BASE_URL = 'https://api.kagami.jp';
const MAX_FILE_SIZE = 10 * 1024 * 1024;

// âœ… æ¨å¥¨ - ã‚¯ãƒ©ã‚¹ã¯ PascalCase
class DataProcessor {}
class FileUploadManager {}
```

### ã‚°ãƒ­ãƒ¼ãƒãƒ«çŠ¶æ…‹ç®¡ç†

```javascript
// çµ±ä¸€ã•ã‚ŒãŸã‚°ãƒ­ãƒ¼ãƒãƒ«çŠ¶æ…‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
const kagamiState = {
    currentSection: 'dashboard',
    user: {
        name: 'ç”°ä¸­ IRæ‹…å½“è€…',
        role: 'ir_manager',
        permissions: ['read', 'write', 'approve']
    },
    notifications: [],
    systemHealth: {}
};
```

### é–¢æ•°ã®æ›¸ãæ–¹

```javascript
// âœ… æ¨å¥¨ - é–¢æ•°å®£è¨€
function initializeApp() {
    console.log('ğŸ”® KAGAMI IRç®¡ç†ã‚»ãƒ³ã‚¿ãƒ¼ - èµ·å‹•ä¸­...');
    // å‡¦ç†å†…å®¹
}

// âœ… æ¨å¥¨ - ã‚¢ãƒ­ãƒ¼é–¢æ•°ï¼ˆçŸ­ã„å‡¦ç†ï¼‰
const saveState = () => {
    localStorage.setItem('kagami_state', JSON.stringify(kagamiState));
};

// âœ… æ¨å¥¨ - async/await
async function fetchDashboardData() {
    try {
        const response = await fetch('/api/dashboard');
        return await response.json();
    } catch (error) {
        console.error('ãƒ‡ãƒ¼ã‚¿å–å¾—ã‚¨ãƒ©ãƒ¼:', error);
        throw error;
    }
}
```

### ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°

```javascript
// âœ… æ¨å¥¨ - try-catchæ–‡
try {
    const result = await processData(data);
    showSuccessMessage('å‡¦ç†ãŒå®Œäº†ã—ã¾ã—ãŸ');
} catch (error) {
    console.error('å‡¦ç†ã‚¨ãƒ©ãƒ¼:', error);
    showErrorMessage('å‡¦ç†ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + error.message);
}
```

---

## ğŸ§© å…±é€šãƒ‘ãƒ¼ãƒ„

### ãƒœã‚¿ãƒ³ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ

```css
.btn {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    padding: var(--space-sm) var(--space-lg);
    border: none;
    border-radius: var(--radius-md);
    font-size: 0.875rem;
    font-weight: 500;
    cursor: pointer;
    transition: var(--transition-normal);
    text-decoration: none;
}

.btn--primary {
    background: var(--kagami-blue);
    color: var(--white);
}

.btn--secondary {
    background: var(--gray-200);
    color: var(--gray-700);
}

.btn--success {
    background: var(--trust-green);
    color: var(--white);
}

.btn--danger {
    background: var(--alert-red);
    color: var(--white);
}
```

### ã‚«ãƒ¼ãƒ‰ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ

```css
.card {
    background: var(--white);
    border-radius: var(--radius-lg);
    box-shadow: var(--shadow-md);
    padding: var(--space-lg);
    transition: var(--transition-normal);
}

.card:hover {
    box-shadow: var(--shadow-lg);
    transform: translateY(-2px);
}

.card__header {
    margin-bottom: var(--space-md);
    padding-bottom: var(--space-md);
    border-bottom: 1px solid var(--gray-200);
}

.card__title {
    font-size: 1.125rem;
    font-weight: 600;
    color: var(--kagami-blue);
    margin: 0;
}
```

### ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ

```css
.modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.6);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
    opacity: 0;
    visibility: hidden;
    transition: var(--transition-normal);
}

.modal-overlay.active {
    opacity: 1;
    visibility: visible;
}

.modal {
    background: var(--white);
    border-radius: var(--radius-lg);
    box-shadow: var(--shadow-xl);
    max-width: 600px;
    width: 90%;
    max-height: 80vh;
    overflow: hidden;
    transform: scale(0.9);
    transition: var(--transition-normal);
}

.modal-overlay.active .modal {
    transform: scale(1);
}
```

---

## ğŸ”§ ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆè¦ç´„

### ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®æ§‹é€ 

å„ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã¯ä»¥ä¸‹ã®æ§‹é€ ã§å®Ÿè£…ã™ã‚‹ï¼š

```
component-name/
â”œâ”€â”€ component-name.html    # HTMLæ§‹é€ 
â”œâ”€â”€ component-name.css     # ã‚¹ã‚¿ã‚¤ãƒ«å®šç¾©
â”œâ”€â”€ component-name.js      # JavaScriptæ©Ÿèƒ½
â””â”€â”€ README.md             # ä½¿ç”¨æ–¹æ³•ã¨ã‚µãƒ³ãƒ—ãƒ«
```

### HTMLæ§‹é€ è¦ç´„

```html
<!-- âœ… æ¨å¥¨ - ã‚»ãƒãƒ³ãƒ†ã‚£ãƒƒã‚¯ãªHTML -->
<section class="data-input-section" role="region" aria-labelledby="section-title">
    <header class="section-header">
        <h2 id="section-title" class="section-title">ãƒ‡ãƒ¼ã‚¿å–è¾¼</h2>
        <p class="section-description">ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ã¦å‡¦ç†ã‚’é–‹å§‹ã—ã¾ã™</p>
    </header>
    
    <div class="section-content">
        <!-- ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ -->
    </div>
</section>
```

### CSSçµ„ç¹”åŒ–

```css
/* component-name.css */

/* ===== ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆåŸºæœ¬ã‚¹ã‚¿ã‚¤ãƒ« ===== */
.component-name {
    /* åŸºæœ¬ã‚¹ã‚¿ã‚¤ãƒ« */
}

/* ===== ãƒãƒªã‚¨ãƒ¼ã‚·ãƒ§ãƒ³ ===== */
.component-name--large {}
.component-name--compact {}

/* ===== çŠ¶æ…‹ ===== */
.component-name.active {}
.component-name.disabled {}

/* ===== å­è¦ç´  ===== */
.component-name__header {}
.component-name__content {}
.component-name__footer {}

/* ===== ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–å¯¾å¿œ ===== */
@media (max-width: 768px) {
    .component-name {
        /* ãƒ¢ãƒã‚¤ãƒ«å¯¾å¿œ */
    }
}
```

### JavaScriptçµ„ç¹”åŒ–

```javascript
// component-name.js

// ===== ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆåˆæœŸåŒ– =====
function initializeComponentName() {
    console.log('ğŸ“¦ ComponentName - åˆæœŸåŒ–ä¸­...');
    
    setupEventListeners();
    loadInitialData();
    
    console.log('âœ… ComponentName - åˆæœŸåŒ–å®Œäº†');
}

// ===== ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼è¨­å®š =====
function setupEventListeners() {
    // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã®è¨­å®š
}

// ===== ãƒ‡ãƒ¼ã‚¿ç®¡ç† =====
function loadInitialData() {
    // åˆæœŸãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿
}

// ===== ãƒ‘ãƒ–ãƒªãƒƒã‚¯API =====
const ComponentName = {
    initialize: initializeComponentName,
    destroy: destroyComponent,
    updateData: updateComponentData
};
```

---

## ğŸ“ ãƒ•ã‚¡ã‚¤ãƒ«æ§‹æˆè¦ç´„

### ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ§‹é€ 

```
cms/
â”œâ”€â”€ index.html              # ãƒ¡ã‚¤ãƒ³ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰
â”œâ”€â”€ styles.css              # å…±é€šã‚¹ã‚¿ã‚¤ãƒ«
â”œâ”€â”€ app.js                 # å…±é€šJavaScript
â”œâ”€â”€ 
â”œâ”€â”€ components/            # å†åˆ©ç”¨å¯èƒ½ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
â”‚   â”œâ”€â”€ button/
â”‚   â”œâ”€â”€ modal/
â”‚   â””â”€â”€ card/
â”œâ”€â”€ 
â”œâ”€â”€ pages/                 # å„æ©Ÿèƒ½ãƒšãƒ¼ã‚¸
â”‚   â”œâ”€â”€ data-input.*       # ãƒ‡ãƒ¼ã‚¿å–è¾¼æ©Ÿèƒ½
â”‚   â”œâ”€â”€ ai-faq.*          # AI-FAQç®¡ç†
â”‚   â”œâ”€â”€ dialogue.*        # å¯¾è©±ç®¡ç†
â”‚   â””â”€â”€ analytics.*       # åˆ†ææ©Ÿèƒ½
â”œâ”€â”€ 
â”œâ”€â”€ assets/               # é™çš„ãƒ•ã‚¡ã‚¤ãƒ«
â”‚   â”œâ”€â”€ images/
â”‚   â”œâ”€â”€ icons/
â”‚   â””â”€â”€ fonts/
â””â”€â”€ 
â””â”€â”€ docs/                 # ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ
    â”œâ”€â”€ coding-guidelines.md
    â”œâ”€â”€ component-library.md
    â””â”€â”€ api-reference.md
```

### ãƒ•ã‚¡ã‚¤ãƒ«å‘½åè¦å‰‡

```
âœ… æ¨å¥¨
- kebab-case: data-input.html, ai-faq.css
- æ©Ÿèƒ½ã‚’è¡¨ã™æ˜ç¢ºãªåå‰: user-management.js
- ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆåå‰: modal-dialog.css

âŒ éæ¨å¥¨
- camelCase: dataInput.html
- ç•¥èª: ui.js, util.css
- æ•°å­—ã®ã¿: page1.html
```

---

## ğŸ·ï¸ å‘½åè¦å‰‡

### CSS ã‚¯ãƒ©ã‚¹å

| ç¨®é¡ | è¦å‰‡ | ä¾‹ |
|------|------|-----|
| ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ | kebab-case | `.data-input-nav` |
| ä¿®é£¾å­ | `--modifier` | `.btn--primary` |
| å­è¦ç´  | `__element` | `.card__header` |
| çŠ¶æ…‹ | `.state` | `.active`, `.disabled` |

### JavaScript

| ç¨®é¡ | è¦å‰‡ | ä¾‹ |
|------|------|-----|
| å¤‰æ•°ãƒ»é–¢æ•° | camelCase | `userName`, `getData()` |
| å®šæ•° | UPPER_SNAKE_CASE | `API_BASE_URL` |
| ã‚¯ãƒ©ã‚¹ | PascalCase | `DataProcessor` |
| ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆ | `_prefix` | `_processData()` |

### HTML

| ç¨®é¡ | è¦å‰‡ | ä¾‹ |
|------|------|-----|
| ID | kebab-case | `#user-profile` |
| dataå±æ€§ | kebab-case | `data-section="user"` |
| ARIA | kebab-case | `aria-labelledby` |

---

## ğŸ’¬ ã‚³ãƒ¡ãƒ³ãƒˆè¦ç´„

### CSS ã‚³ãƒ¡ãƒ³ãƒˆ

```css
/* ===== ã‚»ã‚¯ã‚·ãƒ§ãƒ³åˆ†å‰² ===== */
/* å¤§ããªã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®åŒºåˆ‡ã‚Š */

/* ----- ã‚µãƒ–ã‚»ã‚¯ã‚·ãƒ§ãƒ³ ----- */
/* ä¸­ç¨‹åº¦ã®ã‚°ãƒ«ãƒ¼ãƒ—åˆ†ã‘ */

/* å˜ä¸€ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã®èª¬æ˜ */
.class {
    /* ç‰¹åˆ¥ãªç†ç”±ãŒã‚ã‚‹å ´åˆã®ã¿ */
    transform: translateZ(0); /* GPUåŠ é€Ÿã‚’æœ‰åŠ¹åŒ– */
}
```

### JavaScript ã‚³ãƒ¡ãƒ³ãƒˆ

```javascript
// ===== ã‚»ã‚¯ã‚·ãƒ§ãƒ³åˆ†å‰² =====
// æ©Ÿèƒ½ã®å¤§ããªãƒ–ãƒ­ãƒƒã‚¯

// ----- ã‚µãƒ–æ©Ÿèƒ½ -----
// é–¢é€£ã™ã‚‹é–¢æ•°ç¾¤

/**
 * é–¢æ•°ã®è©³ç´°èª¬æ˜ï¼ˆè¤‡é›‘ãªå‡¦ç†ã®å ´åˆï¼‰
 * @param {string} data - å‡¦ç†å¯¾è±¡ã®ãƒ‡ãƒ¼ã‚¿
 * @param {Object} options - ã‚ªãƒ—ã‚·ãƒ§ãƒ³è¨­å®š
 * @returns {Promise} å‡¦ç†çµæœ
 */
async function processData(data, options) {
    // å®Ÿè£…
}

// çµµæ–‡å­—ã‚’ä½¿ã£ãŸçŠ¶æ³å ±å‘Šï¼ˆKAGAMIå½¢å¼ï¼‰
console.log('ğŸ”® KAGAMI IRç®¡ç†ã‚»ãƒ³ã‚¿ãƒ¼ - èµ·å‹•ä¸­...');
console.log('âœ… å‡¦ç†å®Œäº†');
console.log('âš ï¸ è­¦å‘Šãƒ¡ãƒƒã‚»ãƒ¼ã‚¸');
console.log('âŒ ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿ');
```

### HTML ã‚³ãƒ¡ãƒ³ãƒˆ

```html
<!-- ===== ãƒ˜ãƒƒãƒ€ãƒ¼ã‚»ã‚¯ã‚·ãƒ§ãƒ³ ===== -->
<!-- å¤§ããªã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®é–‹å§‹ -->

<!-- TODO: å°†æ¥çš„ãªæ©Ÿèƒ½è¿½åŠ  -->
<!-- FIXME: æ—¢çŸ¥ã®å•é¡Œ -->
<!-- NOTE: é‡è¦ãªæ³¨æ„äº‹é … -->
```

---

## ğŸ” å“è³ªãƒã‚§ãƒƒã‚¯é …ç›®

### CSS ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ
- [ ] CSSå¤‰æ•°ã‚’é©åˆ‡ã«ä½¿ç”¨ã—ã¦ã„ã‚‹
- [ ] ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–ãƒ‡ã‚¶ã‚¤ãƒ³ã«å¯¾å¿œã—ã¦ã„ã‚‹
- [ ] ã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£è¦ä»¶ã‚’æº€ãŸã—ã¦ã„ã‚‹
- [ ] ãƒ–ãƒ©ã‚¦ã‚¶é–“ã®äº’æ›æ€§ã‚’è€ƒæ…®ã—ã¦ã„ã‚‹
- [ ] é©åˆ‡ãªå‘½åè¦å‰‡ã‚’ä½¿ç”¨ã—ã¦ã„ã‚‹

### JavaScript ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ
- [ ] ES6+ã®è¨˜æ³•ã‚’æ´»ç”¨ã—ã¦ã„ã‚‹
- [ ] ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ãŒé©åˆ‡ã«å®Ÿè£…ã•ã‚Œã¦ã„ã‚‹
- [ ] ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯ã®åŸå› ã¨ãªã‚‹ã‚³ãƒ¼ãƒ‰ãŒãªã„
- [ ] ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã‚’è€ƒæ…®ã—ãŸå®Ÿè£…ã«ãªã£ã¦ã„ã‚‹
- [ ] ã‚³ãƒ¼ãƒ‰ã®å¯èª­æ€§ãŒç¢ºä¿ã•ã‚Œã¦ã„ã‚‹

### å…¨èˆ¬ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ
- [ ] é©åˆ‡ãªã‚³ãƒ¡ãƒ³ãƒˆãŒè¨˜è¼‰ã•ã‚Œã¦ã„ã‚‹
- [ ] ãƒ•ã‚¡ã‚¤ãƒ«æ§‹æˆãŒè¦ç´„ã«å¾“ã£ã¦ã„ã‚‹
- [ ] ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¦ä»¶ã‚’æº€ãŸã—ã¦ã„ã‚‹
- [ ] ãƒ†ã‚¹ã‚¿ãƒ“ãƒªãƒ†ã‚£ãŒç¢ºä¿ã•ã‚Œã¦ã„ã‚‹

---

## ğŸš€ é«˜åº¦ãªè¨­è¨ˆãƒ‘ã‚¿ãƒ¼ãƒ³

### ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£åŸå‰‡

#### ãƒ¢ã‚¸ãƒ¥ãƒ©ãƒ¼è¨­è¨ˆ

```javascript
// âœ… æ¨å¥¨ - ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å¢ƒç•ŒãŒæ˜ç¢º
const FileUploadModule = {
    // ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆçŠ¶æ…‹
    _state: {
        uploadQueue: new Map(),
        activeUploads: new Set(),
        maxConcurrent: 3
    },
    
    // ãƒ‘ãƒ–ãƒªãƒƒã‚¯API
    public: {
        upload: function(files, options) {
            return FileUploadModule._processUpload(files, options);
        },
        
        cancel: function(uploadId) {
            return FileUploadModule._cancelUpload(uploadId);
        },
        
        getStatus: function(uploadId) {
            return FileUploadModule._state.uploadQueue.get(uploadId);
        }
    },
    
    // ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆãƒ¡ã‚½ãƒƒãƒ‰
    _processUpload: function(files, options) {
        // å®Ÿè£…
    },
    
    _cancelUpload: function(uploadId) {
        // å®Ÿè£…
    }
};

// ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å…¬é–‹
window.KAGAMI.modules.FileUpload = FileUploadModule.public;
```

#### ä¾å­˜æ€§æ³¨å…¥ãƒ‘ã‚¿ãƒ¼ãƒ³

```javascript
// âœ… æ¨å¥¨ - ä¾å­˜æ€§ã‚’å¤–éƒ¨ã‹ã‚‰æ³¨å…¥
class DataProcessor {
    constructor(dependencies = {}) {
        this.api = dependencies.api || KAGAMI.api;
        this.logger = dependencies.logger || KAGAMI.logger;
        this.validator = dependencies.validator || KAGAMI.validator;
        this.eventBus = dependencies.eventBus || KAGAMI.events;
    }
    
    async processFile(file) {
        try {
            this.logger.info('ãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†é–‹å§‹', { filename: file.name });
            
            // ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
            const validationResult = await this.validator.validateFile(file);
            if (!validationResult.isValid) {
                throw new Error(`ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚¨ãƒ©ãƒ¼: ${validationResult.errors.join(', ')}`);
            }
            
            // APIå‘¼ã³å‡ºã—
            const result = await this.api.post('/process', { file });
            
            // ã‚¤ãƒ™ãƒ³ãƒˆç™ºç«
            this.eventBus.emit('file:processed', { file, result });
            
            this.logger.info('ãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†å®Œäº†', { filename: file.name, resultId: result.id });
            return result;
            
        } catch (error) {
            this.logger.error('ãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†ã‚¨ãƒ©ãƒ¼', { filename: file.name, error: error.message });
            this.eventBus.emit('file:error', { file, error });
            throw error;
        }
    }
}
```

#### ã‚¹ãƒˆãƒ©ãƒ†ã‚¸ãƒ¼ãƒ‘ã‚¿ãƒ¼ãƒ³

```javascript
// âœ… æ¨å¥¨ - å‡¦ç†æ–¹æ³•ã‚’å‹•çš„ã«å¤‰æ›´å¯èƒ½
const ProcessingStrategies = {
    'pdf': {
        validate: (file) => file.type === 'application/pdf',
        process: async (file) => {
            // PDFå°‚ç”¨å‡¦ç†
            return await KAGAMI.api.post('/process/pdf', { file });
        },
        preview: (file) => {
            // PDFãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ç”Ÿæˆ
            return KAGAMI.ui.generatePdfPreview(file);
        }
    },
    
    'excel': {
        validate: (file) => file.type.includes('spreadsheet'),
        process: async (file) => {
            // Excelå°‚ç”¨å‡¦ç†
            return await KAGAMI.api.post('/process/excel', { file });
        },
        preview: (file) => {
            // Excelãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ç”Ÿæˆ
            return KAGAMI.ui.generateExcelPreview(file);
        }
    },
    
    'default': {
        validate: () => true,
        process: async (file) => {
            // æ±ç”¨å‡¦ç†
            return await KAGAMI.api.post('/process/generic', { file });
        },
        preview: (file) => {
            // æ±ç”¨ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼
            return KAGAMI.ui.generateGenericPreview(file);
        }
    }
};

class FileProcessor {
    process(file) {
        const strategy = this.getStrategy(file);
        return strategy.process(file);
    }
    
    getStrategy(file) {
        for (const [type, strategy] of Object.entries(ProcessingStrategies)) {
            if (strategy.validate(file)) {
                return strategy;
            }
        }
        return ProcessingStrategies.default;
    }
}
```

#### è¦³å¯Ÿè€…ãƒ‘ã‚¿ãƒ¼ãƒ³ã®é«˜åº¦åŒ–

```javascript
// âœ… æ¨å¥¨ - å‹å®‰å…¨ãªã‚¤ãƒ™ãƒ³ãƒˆã‚·ã‚¹ãƒ†ãƒ 
class TypedEventBus {
    constructor() {
        this.listeners = new Map();
        this.middleware = [];
    }
    
    // ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢è¿½åŠ 
    use(middleware) {
        this.middleware.push(middleware);
    }
    
    // ã‚¤ãƒ™ãƒ³ãƒˆè³¼èª­
    on(eventType, listener, options = {}) {
        if (!this.listeners.has(eventType)) {
            this.listeners.set(eventType, new Set());
        }
        
        const wrappedListener = {
            fn: listener,
            once: options.once || false,
            priority: options.priority || 0,
            namespace: options.namespace || 'global'
        };
        
        this.listeners.get(eventType).add(wrappedListener);
        
        // å‰Šé™¤ç”¨é–¢æ•°ã‚’è¿”ã™
        return () => this.off(eventType, wrappedListener);
    }
    
    // ã‚¤ãƒ™ãƒ³ãƒˆç™ºç«
    async emit(eventType, data) {
        // ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢å®Ÿè¡Œ
        for (const middleware of this.middleware) {
            await middleware(eventType, data);
        }
        
        const listeners = this.listeners.get(eventType);
        if (!listeners) return;
        
        // å„ªå…ˆåº¦é †ã§ã‚½ãƒ¼ãƒˆ
        const sortedListeners = Array.from(listeners)
            .sort((a, b) => b.priority - a.priority);
        
        for (const listener of sortedListeners) {
            try {
                await listener.fn(data);
                
                // once ãƒªã‚¹ãƒŠãƒ¼ã¯å‰Šé™¤
                if (listener.once) {
                    listeners.delete(listener);
                }
            } catch (error) {
                console.error(`ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚¨ãƒ©ãƒ¼ [${eventType}]:`, error);
            }
        }
    }
    
    // åå‰ç©ºé–“å˜ä½ã§ã®å‰Šé™¤
    offNamespace(namespace) {
        for (const [eventType, listeners] of this.listeners) {
            for (const listener of listeners) {
                if (listener.namespace === namespace) {
                    listeners.delete(listener);
                }
            }
        }
    }
}

// ä½¿ç”¨ä¾‹
const eventBus = new TypedEventBus();

// ãƒ­ã‚°ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢
eventBus.use(async (eventType, data) => {
    console.log(`Event: ${eventType}`, data);
});

// é«˜å„ªå…ˆåº¦ãƒªã‚¹ãƒŠãƒ¼
eventBus.on('file:uploaded', handleCriticalFileUpload, { priority: 100 });

// ä¸€å›é™ã‚Šã®ãƒªã‚¹ãƒŠãƒ¼
eventBus.on('user:login', handleFirstLogin, { once: true });

// åå‰ç©ºé–“ä»˜ããƒªã‚¹ãƒŠãƒ¼
eventBus.on('data:updated', handleDataUpdate, { namespace: 'dashboard' });
```

### çŠ¶æ…‹ç®¡ç†ãƒ‘ã‚¿ãƒ¼ãƒ³

#### ä¸­å¤®é›†æ¨©å‹çŠ¶æ…‹ç®¡ç†

```javascript
// âœ… æ¨å¥¨ - Reduxé¢¨ã®çŠ¶æ…‹ç®¡ç†
class StateManager {
    constructor() {
        this.state = this.getInitialState();
        this.listeners = new Set();
        this.middleware = [];
        this.devMode = KAGAMI.config.debug;
    }
    
    getInitialState() {
        return {
            user: {
                isAuthenticated: false,
                profile: null,
                permissions: []
            },
            files: {
                uploadQueue: [],
                processing: [],
                completed: [],
                errors: []
            },
            ui: {
                activeModal: null,
                loading: false,
                notifications: []
            },
            system: {
                health: 'unknown',
                lastSync: null,
                version: '1.0.0'
            }
        };
    }
    
    // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³å®Ÿè¡Œ
    dispatch(action) {
        if (this.devMode) {
            console.group(`ğŸ”„ Action: ${action.type}`);
            console.log('Previous State:', this.state);
            console.log('Action:', action);
        }
        
        // ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢å®Ÿè¡Œ
        let nextAction = action;
        for (const middleware of this.middleware) {
            nextAction = middleware(nextAction, this.state);
        }
        
        // ãƒªãƒ‡ãƒ¥ãƒ¼ã‚µãƒ¼å®Ÿè¡Œ
        const newState = this.reduce(this.state, nextAction);
        
        if (this.devMode) {
            console.log('New State:', newState);
            console.groupEnd();
        }
        
        // çŠ¶æ…‹å¤‰æ›´æ¤œçŸ¥
        if (newState !== this.state) {
            const oldState = this.state;
            this.state = newState;
            this.notifyListeners(oldState, newState, action);
        }
    }
    
    // ãƒªãƒ‡ãƒ¥ãƒ¼ã‚µãƒ¼
    reduce(state, action) {
        switch (action.type) {
            case 'USER_LOGIN':
                return {
                    ...state,
                    user: {
                        ...state.user,
                        isAuthenticated: true,
                        profile: action.payload.user
                    }
                };
                
            case 'FILE_UPLOAD_START':
                return {
                    ...state,
                    files: {
                        ...state.files,
                        uploadQueue: [...state.files.uploadQueue, action.payload.file]
                    }
                };
                
            case 'FILE_UPLOAD_COMPLETE':
                return {
                    ...state,
                    files: {
                        ...state.files,
                        uploadQueue: state.files.uploadQueue.filter(f => f.id !== action.payload.fileId),
                        completed: [...state.files.completed, action.payload.result]
                    }
                };
                
            default:
                return state;
        }
    }
    
    // çŠ¶æ…‹ç›£è¦–
    subscribe(listener) {
        this.listeners.add(listener);
        return () => this.listeners.delete(listener);
    }
    
    // ã‚»ãƒ¬ã‚¯ã‚¿ãƒ¼
    select(selector) {
        return selector(this.state);
    }
    
    // éåŒæœŸã‚¢ã‚¯ã‚·ãƒ§ãƒ³å¯¾å¿œ
    async dispatchAsync(asyncAction) {
        if (typeof asyncAction === 'function') {
            return await asyncAction(this.dispatch.bind(this), this.select.bind(this));
        }
        return this.dispatch(asyncAction);
    }
}

// ã‚»ãƒ¬ã‚¯ã‚¿ãƒ¼å®šç¾©
const Selectors = {
    getUser: (state) => state.user,
    getUploadQueue: (state) => state.files.uploadQueue,
    getActiveModal: (state) => state.ui.activeModal,
    getSystemHealth: (state) => state.system.health
};

// ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚¯ãƒªã‚¨ã‚¤ã‚¿ãƒ¼
const Actions = {
    userLogin: (user) => ({
        type: 'USER_LOGIN',
        payload: { user }
    }),
    
    fileUploadStart: (file) => ({
        type: 'FILE_UPLOAD_START',
        payload: { file }
    }),
    
    // éåŒæœŸã‚¢ã‚¯ã‚·ãƒ§ãƒ³
    uploadFileAsync: (file) => async (dispatch, select) => {
        dispatch(Actions.fileUploadStart(file));
        
        try {
            const result = await KAGAMI.api.upload(file);
            dispatch({
                type: 'FILE_UPLOAD_COMPLETE',
                payload: { fileId: file.id, result }
            });
        } catch (error) {
            dispatch({
                type: 'FILE_UPLOAD_ERROR',
                payload: { fileId: file.id, error }
            });
        }
    }
};
```

---

## âš¡ ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–

### ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°æœ€é©åŒ–

#### ä»®æƒ³åŒ–ãƒ†ã‚¯ãƒ‹ãƒƒã‚¯

```javascript
// âœ… æ¨å¥¨ - å¤§é‡ãƒ‡ãƒ¼ã‚¿ã®åŠ¹ç‡çš„ãªè¡¨ç¤º
class VirtualizedList {
    constructor(container, options = {}) {
        this.container = container;
        this.itemHeight = options.itemHeight || 50;
        this.buffer = options.buffer || 5;
        this.items = [];
        this.visibleItems = new Map();
        this.scrollTop = 0;
        
        this.setupScrollListener();
    }
    
    setItems(items) {
        this.items = items;
        this.updateVirtualization();
    }
    
    setupScrollListener() {
        let ticking = false;
        
        this.container.addEventListener('scroll', () => {
            if (!ticking) {
                requestAnimationFrame(() => {
                    this.handleScroll();
                    ticking = false;
                });
                ticking = true;
            }
        });
    }
    
    handleScroll() {
        this.scrollTop = this.container.scrollTop;
        this.updateVirtualization();
    }
    
    updateVirtualization() {
        const containerHeight = this.container.clientHeight;
        const startIndex = Math.max(0, Math.floor(this.scrollTop / this.itemHeight) - this.buffer);
        const endIndex = Math.min(
            this.items.length - 1,
            Math.ceil((this.scrollTop + containerHeight) / this.itemHeight) + this.buffer
        );
        
        // ä¸è¦ãªè¦ç´ ã‚’å‰Šé™¤
        for (const [index, element] of this.visibleItems) {
            if (index < startIndex || index > endIndex) {
                element.remove();
                this.visibleItems.delete(index);
            }
        }
        
        // å¿…è¦ãªè¦ç´ ã‚’è¿½åŠ 
        for (let i = startIndex; i <= endIndex; i++) {
            if (!this.visibleItems.has(i) && this.items[i]) {
                const element = this.createItemElement(this.items[i], i);
                this.visibleItems.set(i, element);
                this.container.appendChild(element);
            }
        }
        
        // ç·é«˜ã•è¨­å®š
        this.container.style.height = `${this.items.length * this.itemHeight}px`;
    }
    
    createItemElement(item, index) {
        const element = document.createElement('div');
        element.className = 'virtual-list-item';
        element.style.position = 'absolute';
        element.style.top = `${index * this.itemHeight}px`;
        element.style.height = `${this.itemHeight}px`;
        element.innerHTML = this.renderItem(item);
        return element;
    }
    
    renderItem(item) {
        // ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã§ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰
        return `<div>${item.name}</div>`;
    }
}
```

#### ãƒ¡ãƒ¢åŒ–ã¨ã‚­ãƒ£ãƒƒã‚·ãƒ¥

```javascript
// âœ… æ¨å¥¨ - è¨ˆç®—çµæœã®ãƒ¡ãƒ¢åŒ–
class MemoizationCache {
    constructor(maxSize = 100) {
        this.cache = new Map();
        this.maxSize = maxSize;
        this.accessOrder = new Set();
    }
    
    memoize(fn, keyGenerator = (...args) => JSON.stringify(args)) {
        return (...args) => {
            const key = keyGenerator(...args);
            
            if (this.cache.has(key)) {
                // LRUæ›´æ–°
                this.accessOrder.delete(key);
                this.accessOrder.add(key);
                return this.cache.get(key);
            }
            
            const result = fn(...args);
            this.set(key, result);
            return result;
        };
    }
    
    set(key, value) {
        // ã‚µã‚¤ã‚ºåˆ¶é™ãƒã‚§ãƒƒã‚¯
        if (this.cache.size >= this.maxSize) {
            const oldest = this.accessOrder.values().next().value;
            this.cache.delete(oldest);
            this.accessOrder.delete(oldest);
        }
        
        this.cache.set(key, value);
        this.accessOrder.add(key);
    }
    
    clear() {
        this.cache.clear();
        this.accessOrder.clear();
    }
}

// ä½¿ç”¨ä¾‹
const memoCache = new MemoizationCache(50);

const expensiveCalculation = memoCache.memoize((data) => {
    // é‡ã„è¨ˆç®—å‡¦ç†
    return data.reduce((sum, item) => sum + item.value, 0);
});

// DOMæ“ä½œã®ãƒ¡ãƒ¢åŒ–
const memoizedFormatDate = memoCache.memoize(
    (date, format) => KAGAMI.utils.formatDate(date, format),
    (date, format) => `${date.getTime()}_${format}`
);
```

#### ãƒãƒƒãƒå‡¦ç†ã¨ãƒ‡ãƒã‚¦ãƒ³ã‚¹

```javascript
// âœ… æ¨å¥¨ - åŠ¹ç‡çš„ãªæ›´æ–°ãƒãƒƒãƒå‡¦ç†
class BatchProcessor {
    constructor(options = {}) {
        this.batchSize = options.batchSize || 50;
        this.delay = options.delay || 16; // 1ãƒ•ãƒ¬ãƒ¼ãƒ 
        this.queue = [];
        this.processing = false;
        this.scheduler = options.scheduler || requestAnimationFrame;
    }
    
    add(operation) {
        this.queue.push(operation);
        this.scheduleProcessing();
    }
    
    scheduleProcessing() {
        if (!this.processing) {
            this.processing = true;
            this.scheduler(() => this.processBatch());
        }
    }
    
    processBatch() {
        const batch = this.queue.splice(0, this.batchSize);
        
        for (const operation of batch) {
            try {
                operation();
            } catch (error) {
                console.error('ãƒãƒƒãƒå‡¦ç†ã‚¨ãƒ©ãƒ¼:', error);
            }
        }
        
        if (this.queue.length > 0) {
            this.scheduler(() => this.processBatch());
        } else {
            this.processing = false;
        }
    }
}

// ãƒ‡ãƒã‚¦ãƒ³ã‚¹ãƒ»ã‚¹ãƒ­ãƒƒãƒˆãƒ«
class EventThrottler {
    static debounce(fn, delay) {
        let timeoutId;
        return function(...args) {
            clearTimeout(timeoutId);
            timeoutId = setTimeout(() => fn.apply(this, args), delay);
        };
    }
    
    static throttle(fn, limit) {
        let inThrottle;
        return function(...args) {
            if (!inThrottle) {
                fn.apply(this, args);
                inThrottle = true;
                setTimeout(() => inThrottle = false, limit);
            }
        };
    }
    
    static rafThrottle(fn) {
        let scheduled = false;
        return function(...args) {
            if (!scheduled) {
                scheduled = true;
                requestAnimationFrame(() => {
                    fn.apply(this, args);
                    scheduled = false;
                });
            }
        };
    }
}

// ä½¿ç”¨ä¾‹
const batchProcessor = new BatchProcessor();
const debouncedSearch = EventThrottler.debounce(performSearch, 300);
const throttledScroll = EventThrottler.rafThrottle(handleScroll);
```

### ãƒ¡ãƒ¢ãƒªç®¡ç†

#### ãƒªãƒ¼ã‚¯ã‚’é˜²ããƒ‘ã‚¿ãƒ¼ãƒ³

```javascript
// âœ… æ¨å¥¨ - é©åˆ‡ãªã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
class ComponentLifecycle {
    constructor() {
        this.subscriptions = new Set();
        this.timeouts = new Set();
        this.intervals = new Set();
        this.abortControllers = new Set();
        this.observers = new Set();
    }
    
    // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ç®¡ç†
    addEventListener(element, event, handler, options) {
        element.addEventListener(event, handler, options);
        
        const cleanup = () => element.removeEventListener(event, handler, options);
        this.subscriptions.add(cleanup);
        return cleanup;
    }
    
    // ã‚¿ã‚¤ãƒãƒ¼ç®¡ç†
    setTimeout(callback, delay) {
        const id = setTimeout(callback, delay);
        this.timeouts.add(id);
        return id;
    }
    
    setInterval(callback, delay) {
        const id = setInterval(callback, delay);
        this.intervals.add(id);
        return id;
    }
    
    // AbortControllerç®¡ç†
    createAbortController() {
        const controller = new AbortController();
        this.abortControllers.add(controller);
        return controller;
    }
    
    // Observerç®¡ç†
    observe(target, observer) {
        observer.observe(target);
        this.observers.add({ observer, target });
    }
    
    // ä¸€æ‹¬ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
    destroy() {
        // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼å‰Šé™¤
        for (const cleanup of this.subscriptions) {
            cleanup();
        }
        this.subscriptions.clear();
        
        // ã‚¿ã‚¤ãƒãƒ¼å‰Šé™¤
        for (const id of this.timeouts) {
            clearTimeout(id);
        }
        this.timeouts.clear();
        
        for (const id of this.intervals) {
            clearInterval(id);
        }
        this.intervals.clear();
        
        // ãƒªã‚¯ã‚¨ã‚¹ãƒˆä¸­æ–­
        for (const controller of this.abortControllers) {
            controller.abort();
        }
        this.abortControllers.clear();
        
        // Observeråœæ­¢
        for (const { observer, target } of this.observers) {
            observer.unobserve(target);
        }
        this.observers.clear();
    }
}

// WeakMap/WeakSetã®æ´»ç”¨
class WeakReferenceManager {
    constructor() {
        this.elementData = new WeakMap();
        this.eventHandlers = new WeakMap();
    }
    
    setElementData(element, data) {
        this.elementData.set(element, data);
    }
    
    getElementData(element) {
        return this.elementData.get(element);
    }
    
    bindEventHandler(element, handler) {
        this.eventHandlers.set(element, handler);
        element.addEventListener('click', handler);
    }
    
    // è¦ç´ ãŒå‰Šé™¤ã•ã‚Œã‚‹ã¨è‡ªå‹•çš„ã«WeakMapã‹ã‚‰ã‚‚å‰Šé™¤ã•ã‚Œã‚‹
}
```

---

## ğŸ”’ ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¦ä»¶

### å…¥åŠ›å€¤æ¤œè¨¼ã¨ã‚µãƒ‹ã‚¿ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³

```javascript
// âœ… æ¨å¥¨ - å …ç‰¢ãªå…¥åŠ›å€¤æ¤œè¨¼
class SecurityValidator {
    static patterns = {
        email: /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/,
        phone: /^[0-9-+().\s]+$/,
        alphanumeric: /^[a-zA-Z0-9]+$/,
        filename: /^[a-zA-Z0-9._-]+$/,
        url: /^https?:\/\/[^\s$.?#].[^\s]*$/i
    };
    
    static validateInput(value, type, options = {}) {
        if (typeof value !== 'string') {
            throw new Error('å…¥åŠ›å€¤ã¯æ–‡å­—åˆ—ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™');
        }
        
        // é•·ã•ãƒã‚§ãƒƒã‚¯
        if (options.minLength && value.length < options.minLength) {
            throw new Error(`å…¥åŠ›å€¤ã¯${options.minLength}æ–‡å­—ä»¥ä¸Šã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™`);
        }
        
        if (options.maxLength && value.length > options.maxLength) {
            throw new Error(`å…¥åŠ›å€¤ã¯${options.maxLength}æ–‡å­—ä»¥ä¸‹ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™`);
        }
        
        // ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒã‚§ãƒƒã‚¯
        if (this.patterns[type] && !this.patterns[type].test(value)) {
            throw new Error(`å…¥åŠ›å€¤ãŒ${type}ã®å½¢å¼ã«åˆã„ã¾ã›ã‚“`);
        }
        
        // ã‚«ã‚¹ã‚¿ãƒ ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
        if (options.customValidator) {
            const result = options.customValidator(value);
            if (!result.isValid) {
                throw new Error(result.message);
            }
        }
        
        return true;
    }
    
    static sanitizeHtml(html) {
        const allowedTags = ['p', 'br', 'strong', 'em', 'u', 'ol', 'ul', 'li'];
        const allowedAttributes = {
            'a': ['href', 'title'],
            'img': ['src', 'alt', 'width', 'height']
        };
        
        // ç°¡æ˜“HTMLã‚µãƒ‹ã‚¿ã‚¤ã‚¶ãƒ¼ï¼ˆæœ¬ç•ªã§ã¯å°‚ç”¨ãƒ©ã‚¤ãƒ–ãƒ©ãƒªä½¿ç”¨æ¨å¥¨ï¼‰
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = html;
        
        const sanitize = (element) => {
            for (let i = element.children.length - 1; i >= 0; i--) {
                const child = element.children[i];
                
                if (!allowedTags.includes(child.tagName.toLowerCase())) {
                    child.remove();
                    continue;
                }
                
                // å±æ€§ãƒã‚§ãƒƒã‚¯
                const allowedAttrs = allowedAttributes[child.tagName.toLowerCase()] || [];
                for (let j = child.attributes.length - 1; j >= 0; j--) {
                    const attr = child.attributes[j];
                    if (!allowedAttrs.includes(attr.name)) {
                        child.removeAttribute(attr.name);
                    }
                }
                
                sanitize(child);
            }
        };
        
        sanitize(tempDiv);
        return tempDiv.innerHTML;
    }
    
    static escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
    
    static validateFileUpload(file, options = {}) {
        const allowedTypes = options.allowedTypes || ['.pdf', '.docx', '.xlsx'];
        const maxSize = options.maxSize || 50 * 1024 * 1024; // 50MB
        
        // ãƒ•ã‚¡ã‚¤ãƒ«ã‚¿ã‚¤ãƒ—ãƒã‚§ãƒƒã‚¯
        const fileExtension = '.' + file.name.split('.').pop().toLowerCase();
        if (!allowedTypes.includes(fileExtension)) {
            throw new Error(`è¨±å¯ã•ã‚Œã¦ã„ãªã„ãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼ã§ã™: ${fileExtension}`);
        }
        
        // ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºãƒã‚§ãƒƒã‚¯
        if (file.size > maxSize) {
            throw new Error(`ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºãŒä¸Šé™ã‚’è¶…ãˆã¦ã„ã¾ã™: ${file.size} > ${maxSize}`);
        }
        
        // MIMEã‚¿ã‚¤ãƒ—ãƒã‚§ãƒƒã‚¯
        const allowedMimeTypes = {
            '.pdf': 'application/pdf',
            '.docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
            '.xlsx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
        };
        
        const expectedMimeType = allowedMimeTypes[fileExtension];
        if (expectedMimeType && file.type !== expectedMimeType) {
            throw new Error(`ãƒ•ã‚¡ã‚¤ãƒ«ã®å†…å®¹ã¨æ‹¡å¼µå­ãŒä¸€è‡´ã—ã¾ã›ã‚“`);
        }
        
        return true;
    }
}
```

### CSP (Content Security Policy) å¯¾å¿œ

```javascript
// âœ… æ¨å¥¨ - CSPæº–æ‹ ã®ã‚³ãƒ¼ãƒ‰
class SecureScriptLoader {
    static loadScript(src, options = {}) {
        return new Promise((resolve, reject) => {
            // nonceå±æ€§ã®å–å¾—
            const metaTag = document.querySelector('meta[name="csp-nonce"]');
            const nonce = metaTag ? metaTag.content : null;
            
            const script = document.createElement('script');
            script.src = src;
            script.async = options.async !== false;
            script.defer = options.defer || false;
            
            if (nonce) {
                script.setAttribute('nonce', nonce);
            }
            
            script.onload = resolve;
            script.onerror = reject;
            
            document.head.appendChild(script);
        });
    }
    
    static executeSecureCode(code, context = {}) {
        // evalä½¿ç”¨ã‚’é¿ã‘ã¦Function constructorã‚’ä½¿ç”¨
        try {
            const func = new Function(...Object.keys(context), code);
            return func(...Object.values(context));
        } catch (error) {
            console.error('ã‚»ã‚­ãƒ¥ã‚¢ã‚³ãƒ¼ãƒ‰å®Ÿè¡Œã‚¨ãƒ©ãƒ¼:', error);
            throw error;
        }
    }
}

// âœ… æ¨å¥¨ - XSSå¯¾ç­–
class XSSProtection {
    static createSecureElement(tagName, properties = {}) {
        const element = document.createElement(tagName);
        
        for (const [key, value] of Object.entries(properties)) {
            if (key === 'innerHTML' || key === 'outerHTML') {
                // HTMLã¯å¸¸ã«ã‚µãƒ‹ã‚¿ã‚¤ã‚º
                element.innerHTML = SecurityValidator.sanitizeHtml(value);
            } else if (key === 'textContent') {
                // ãƒ†ã‚­ã‚¹ãƒˆã¯å®‰å…¨
                element.textContent = value;
            } else if (key.startsWith('on')) {
                // ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã¯é–¢æ•°ã®ã¿è¨±å¯
                if (typeof value === 'function') {
                    element[key] = value;
                }
            } else {
                // ãã®ä»–ã®å±æ€§ã¯æ–‡å­—åˆ—ã¨ã—ã¦è¨­å®š
                element.setAttribute(key, String(value));
            }
        }
        
        return element;
    }
    
    static setSecureAttribute(element, name, value) {
        // å±é™ºãªå±æ€§ã®ãƒã‚§ãƒƒã‚¯
        const dangerousAttributes = ['src', 'href', 'action', 'formaction'];
        
        if (dangerousAttributes.includes(name)) {
            // URLã®æ¤œè¨¼
            if (name === 'href' || name === 'src') {
                if (!this.isSecureUrl(value)) {
                    console.warn(`å±é™ºãªURL: ${value}`);
                    return false;
                }
            }
        }
        
        element.setAttribute(name, value);
        return true;
    }
    
    static isSecureUrl(url) {
        try {
            const parsed = new URL(url, window.location.origin);
            // HTTPSã¾ãŸã¯ç›¸å¯¾URLã®ã¿è¨±å¯
            return parsed.protocol === 'https:' || 
                   parsed.protocol === 'http:' && window.location.protocol === 'http:' ||
                   !parsed.protocol; // ç›¸å¯¾URL
        } catch {
            return false;
        }
    }
}
```

---

## ğŸ§ª ãƒ†ã‚¹ãƒˆæˆ¦ç•¥

### ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆ

```javascript
// âœ… æ¨å¥¨ - ãƒ†ã‚¹ã‚¿ãƒ–ãƒ«ãªã‚³ãƒ¼ãƒ‰è¨­è¨ˆ
class TestableFileProcessor {
    constructor(dependencies = {}) {
        this.api = dependencies.api || KAGAMI.api;
        this.validator = dependencies.validator || SecurityValidator;
        this.logger = dependencies.logger || console;
    }
    
    async processFile(file) {
        // ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
        this.validator.validateFileUpload(file);
        
        // å‡¦ç†
        const result = await this.api.post('/process', { file });
        
        // ãƒ­ã‚°
        this.logger.info('ãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†å®Œäº†', { filename: file.name });
        
        return result;
    }
}

// ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ä¾‹
function testFileProcessor() {
    // ãƒ¢ãƒƒã‚¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
    const mockApi = {
        post: jest.fn().mockResolvedValue({ id: 123, status: 'completed' })
    };
    
    const mockValidator = {
        validateFileUpload: jest.fn()
    };
    
    const mockLogger = {
        info: jest.fn()
    };
    
    const processor = new TestableFileProcessor({
        api: mockApi,
        validator: mockValidator,
        logger: mockLogger
    });
    
    const testFile = new File(['test content'], 'test.pdf', { type: 'application/pdf' });
    
    // ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
    return processor.processFile(testFile).then(result => {
        // ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³
        expect(mockValidator.validateFileUpload).toHaveBeenCalledWith(testFile);
        expect(mockApi.post).toHaveBeenCalledWith('/process', { file: testFile });
        expect(mockLogger.info).toHaveBeenCalled();
        expect(result.id).toBe(123);
    });
}
```

### E2Eãƒ†ã‚¹ãƒˆè‡ªå‹•åŒ–å¯¾å¿œ

```javascript
// âœ… æ¨å¥¨ - ãƒ†ã‚¹ãƒˆè‡ªå‹•åŒ–ã‚’è€ƒæ…®ã—ãŸãƒãƒ¼ã‚¯ã‚¢ãƒƒãƒ—
class TestAutomationHelper {
    static addTestIds(container) {
        // æœ¬ç•ªç’°å¢ƒã§ã¯ä½•ã‚‚ã—ãªã„
        if (!KAGAMI.config.debug) return;
        
        // é‡è¦ãªè¦ç´ ã«test-idå±æ€§ã‚’è‡ªå‹•ä»˜ä¸
        const importantElements = container.querySelectorAll(`
            button,
            input[type="file"],
            .upload-area,
            .modal,
            .alert,
            [role="tab"],
            [role="button"]
        `);
        
        importantElements.forEach((element, index) => {
            if (!element.getAttribute('data-test-id')) {
                const testId = this.generateTestId(element, index);
                element.setAttribute('data-test-id', testId);
            }
        });
    }
    
    static generateTestId(element, index) {
        const className = element.className.split(' ')[0] || element.tagName.toLowerCase();
        const context = this.getContext(element);
        return `${context}-${className}-${index}`;
    }
    
    static getContext(element) {
        const section = element.closest('[data-section]');
        return section ? section.getAttribute('data-section') : 'global';
    }
    
    // ãƒšãƒ¼ã‚¸çŠ¶æ…‹ã®ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
    static exportPageState() {
        return {
            url: window.location.href,
            title: document.title,
            forms: this.getFormStates(),
            modals: this.getModalStates(),
            notifications: this.getNotificationStates()
        };
    }
    
    static getFormStates() {
        const forms = document.querySelectorAll('form');
        return Array.from(forms).map(form => ({
            id: form.id,
            action: form.action,
            method: form.method,
            fields: this.getFieldStates(form)
        }));
    }
    
    static getFieldStates(form) {
        const fields = form.querySelectorAll('input, select, textarea');
        return Array.from(fields).map(field => ({
            name: field.name,
            type: field.type,
            value: field.value,
            checked: field.checked,
            disabled: field.disabled
        }));
    }
}

// ãƒ†ã‚¹ãƒˆç”¨ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
window.KAGAMI_TEST = {
    // è¦ç´ ã®å¯è¦–æ€§ãƒã‚§ãƒƒã‚¯
    isVisible: (selector) => {
        const element = document.querySelector(selector);
        return element && element.offsetParent !== null;
    },
    
    // ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
    simulateFileUpload: (selector, fileData) => {
        const input = document.querySelector(selector);
        const file = new File([fileData.content], fileData.name, { type: fileData.type });
        
        const dataTransfer = new DataTransfer();
        dataTransfer.items.add(file);
        input.files = dataTransfer.files;
        
        input.dispatchEvent(new Event('change', { bubbles: true }));
    },
    
    // éåŒæœŸå‡¦ç†ã®å®Œäº†å¾…æ©Ÿ
    waitForAsyncOperation: (timeout = 5000) => {
        return new Promise((resolve, reject) => {
            const startTime = Date.now();
            
            const check = () => {
                if (KAGAMI.state.ui.loading === false) {
                    resolve();
                } else if (Date.now() - startTime > timeout) {
                    reject(new Error('ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ'));
                } else {
                    setTimeout(check, 100);
                }
            };
            
            check();
        });
    }
};
```

---

## ğŸ“Š ãƒ­ã‚°ãƒ»ç›£è¦–æˆ¦ç•¥

### æ§‹é€ åŒ–ãƒ­ã‚°

```javascript
// âœ… æ¨å¥¨ - æ§‹é€ åŒ–ãƒ­ã‚°ã‚·ã‚¹ãƒ†ãƒ 
class StructuredLogger {
    constructor(options = {}) {
        this.level = options.level || 'info';
        this.context = options.context || {};
        this.outputs = options.outputs || [console];
        this.buffer = [];
        this.maxBufferSize = options.maxBufferSize || 1000;
    }
    
    static levels = {
        error: 0,
        warn: 1,
        info: 2,
        debug: 3,
        trace: 4
    };
    
    log(level, message, data = {}) {
        const levelNum = StructuredLogger.levels[level];
        const currentLevelNum = StructuredLogger.levels[this.level];
        
        if (levelNum > currentLevelNum) return;
        
        const logEntry = {
            timestamp: new Date().toISOString(),
            level: level,
            message: message,
            data: { ...this.context, ...data },
            sessionId: this.getSessionId(),
            userId: this.getUserId(),
            userAgent: navigator.userAgent,
            url: window.location.href,
            stack: level === 'error' ? new Error().stack : undefined
        };
        
        this.buffer.push(logEntry);
        this.maintainBuffer();
        
        // å‡ºåŠ›
        for (const output of this.outputs) {
            this.outputLog(output, logEntry);
        }
        
        // é‡è¦ãƒ­ã‚°ã®å³åº§é€ä¿¡
        if (level === 'error' || level === 'warn') {
            this.flushToServer([logEntry]);
        }
    }
    
    error(message, data) { this.log('error', message, data); }
    warn(message, data) { this.log('warn', message, data); }
    info(message, data) { this.log('info', message, data); }
    debug(message, data) { this.log('debug', message, data); }
    trace(message, data) { this.log('trace', message, data); }
    
    // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ¸¬å®š
    time(label) {
        const startTime = performance.now();
        return {
            end: () => {
                const duration = performance.now() - startTime;
                this.info(`Performance: ${label}`, { 
                    duration: Math.round(duration * 100) / 100,
                    label: label
                });
                return duration;
            }
        };
    }
    
    // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¢ã‚¯ã‚·ãƒ§ãƒ³è¿½è·¡
    trackUserAction(action, target, data = {}) {
        this.info('User Action', {
            action: action,
            target: target,
            targetId: target.id,
            targetClass: target.className,
            ...data
        });
    }
    
    // ã‚¨ãƒ©ãƒ¼å¢ƒç•Œ
    wrapFunction(fn, name) {
        return (...args) => {
            try {
                const result = fn.apply(this, args);
                
                // Promise ã‚¨ãƒ©ãƒ¼ã‚‚ã‚­ãƒ£ãƒƒãƒ
                if (result && typeof result.catch === 'function') {
                    return result.catch(error => {
                        this.error(`éåŒæœŸã‚¨ãƒ©ãƒ¼ in ${name}`, { 
                            error: error.message, 
                            args: args 
                        });
                        throw error;
                    });
                }
                
                return result;
            } catch (error) {
                this.error(`ã‚¨ãƒ©ãƒ¼ in ${name}`, { 
                    error: error.message, 
                    args: args 
                });
                throw error;
            }
        };
    }
    
    // ãƒãƒƒãƒ•ã‚¡ç®¡ç†
    maintainBuffer() {
        if (this.buffer.length > this.maxBufferSize) {
            const excess = this.buffer.length - this.maxBufferSize;
            this.buffer.splice(0, excess);
        }
    }
    
    // ã‚µãƒ¼ãƒãƒ¼ã¸ã®é€ä¿¡
    async flushToServer(logs = null) {
        const logsToSend = logs || [...this.buffer];
        if (logsToSend.length === 0) return;
        
        try {
            await fetch('/api/logs', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ logs: logsToSend })
            });
            
            // é€ä¿¡æˆåŠŸã—ãŸã‚‰ãƒãƒƒãƒ•ã‚¡ã‹ã‚‰ã‚¯ãƒªã‚¢
            if (!logs) {
                this.buffer.length = 0;
            }
        } catch (error) {
            console.error('ãƒ­ã‚°é€ä¿¡ã‚¨ãƒ©ãƒ¼:', error);
        }
    }
    
    getSessionId() {
        return sessionStorage.getItem('kagami_session_id') || 'unknown';
    }
    
    getUserId() {
        return KAGAMI.state?.user?.id || 'anonymous';
    }
    
    outputLog(output, logEntry) {
        const method = output[logEntry.level] || output.log;
        method.call(output, `[${logEntry.level.toUpperCase()}]`, logEntry.message, logEntry.data);
    }
}

// ã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒ­ã‚¬ãƒ¼è¨­å®š
KAGAMI.logger = new StructuredLogger({
    level: KAGAMI.config.debug ? 'debug' : 'info',
    context: {
        component: 'kagami-ir',
        version: '1.0.0'
    }
});

// æœªå‡¦ç†ã‚¨ãƒ©ãƒ¼ã‚­ãƒ£ãƒƒãƒ
window.addEventListener('error', (event) => {
    KAGAMI.logger.error('æœªå‡¦ç†ã‚¨ãƒ©ãƒ¼', {
        message: event.message,
        filename: event.filename,
        lineno: event.lineno,
        colno: event.colno,
        stack: event.error?.stack
    });
});

window.addEventListener('unhandledrejection', (event) => {
    KAGAMI.logger.error('æœªå‡¦ç†Promiseæ‹’å¦', {
        reason: event.reason,
        stack: event.reason?.stack
    });
});
```

### ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ç›£è¦–

```javascript
// âœ… æ¨å¥¨ - ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–
class PerformanceMonitor {
    constructor() {
        this.metrics = new Map();
        this.observers = new Map();
        this.setupObservers();
    }
    
    setupObservers() {
        // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è¦³æ¸¬
        if ('PerformanceObserver' in window) {
            this.setupPerformanceObserver();
        }
        
        // ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ç›£è¦–
        this.startMemoryMonitoring();
        
        // ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ç›£è¦–
        this.startNetworkMonitoring();
    }
    
    setupPerformanceObserver() {
        const observer = new PerformanceObserver((list) => {
            for (const entry of list.getEntries()) {
                this.recordMetric(entry.entryType, {
                    name: entry.name,
                    duration: entry.duration,
                    startTime: entry.startTime
                });
            }
        });
        
        observer.observe({ entryTypes: ['measure', 'navigation', 'resource'] });
        this.observers.set('performance', observer);
    }
    
    startMemoryMonitoring() {
        if ('memory' in performance) {
            setInterval(() => {
                const memory = performance.memory;
                this.recordMetric('memory', {
                    used: memory.usedJSHeapSize,
                    total: memory.totalJSHeapSize,
                    limit: memory.jsHeapSizeLimit,
                    usage: memory.usedJSHeapSize / memory.jsHeapSizeLimit
                });
            }, 30000); // 30ç§’é–“éš”
        }
    }
    
    startNetworkMonitoring() {
        const originalFetch = window.fetch;
        
        window.fetch = async (...args) => {
            const startTime = performance.now();
            const url = args[0];
            
            try {
                const response = await originalFetch(...args);
                const endTime = performance.now();
                
                this.recordMetric('network', {
                    url: url,
                    method: args[1]?.method || 'GET',
                    status: response.status,
                    duration: endTime - startTime,
                    size: response.headers.get('content-length')
                });
                
                return response;
            } catch (error) {
                const endTime = performance.now();
                
                this.recordMetric('network_error', {
                    url: url,
                    method: args[1]?.method || 'GET',
                    duration: endTime - startTime,
                    error: error.message
                });
                
                throw error;
            }
        };
    }
    
    recordMetric(type, data) {
        if (!this.metrics.has(type)) {
            this.metrics.set(type, []);
        }
        
        const metrics = this.metrics.get(type);
        metrics.push({
            timestamp: Date.now(),
            ...data
        });
        
        // ãƒãƒƒãƒ•ã‚¡ã‚µã‚¤ã‚ºåˆ¶é™
        if (metrics.length > 100) {
            metrics.shift();
        }
        
        // ã‚¢ãƒ©ãƒ¼ãƒˆé–¾å€¤ãƒã‚§ãƒƒã‚¯
        this.checkAlerts(type, data);
    }
    
    checkAlerts(type, data) {
        const alerts = {
            memory: (data) => data.usage > 0.9,
            network: (data) => data.duration > 5000, // 5ç§’ä»¥ä¸Š
            performance: (data) => data.duration > 1000 // 1ç§’ä»¥ä¸Š
        };
        
        if (alerts[type] && alerts[type](data)) {
            KAGAMI.logger.warn(`ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã‚¢ãƒ©ãƒ¼ãƒˆ: ${type}`, data);
            
            // é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ ã¨é€£æº
            KAGAMI.notify.toast(`ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è­¦å‘Š: ${type}`, 'warning');
        }
    }
    
    getReport() {
        const report = {};
        
        for (const [type, metrics] of this.metrics) {
            const recent = metrics.slice(-10); // æœ€æ–°10ä»¶
            report[type] = {
                count: metrics.length,
                recent: recent,
                average: this.calculateAverage(recent, 'duration'),
                max: this.calculateMax(recent, 'duration'),
                min: this.calculateMin(recent, 'duration')
            };
        }
        
        return report;
    }
    
    calculateAverage(metrics, key) {
        const values = metrics.map(m => m[key]).filter(v => typeof v === 'number');
        return values.length ? values.reduce((a, b) => a + b, 0) / values.length : 0;
    }
    
    calculateMax(metrics, key) {
        const values = metrics.map(m => m[key]).filter(v => typeof v === 'number');
        return values.length ? Math.max(...values) : 0;
    }
    
    calculateMin(metrics, key) {
        const values = metrics.map(m => m[key]).filter(v => typeof v === 'number');
        return values.length ? Math.min(...values) : 0;
    }
}
```

---

## ğŸ› ï¸ é–‹ç™ºãƒ„ãƒ¼ãƒ«é€£æº

### è‡ªå‹•ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆè¨­å®š

```json
// .prettierrc
{
  "semi": true,
  "trailingComma": "es5",
  "singleQuote": true,
  "printWidth": 100,
  "tabWidth": 4,
  "useTabs": false,
  "bracketSpacing": true,
  "arrowParens": "avoid",
  "endOfLine": "lf"
}
```

```json
// .eslintrc.json
{
  "env": {
    "browser": true,
    "es2021": true
  },
  "extends": [
    "eslint:recommended"
  ],
  "parserOptions": {
    "ecmaVersion": 12,
    "sourceType": "module"
  },
  "rules": {
    "indent": ["error", 4],
    "quotes": ["error", "single"],
    "semi": ["error", "always"],
    "no-unused-vars": ["error", { "argsIgnorePattern": "^_" }],
    "no-console": ["warn", { "allow": ["warn", "error"] }],
    "prefer-const": "error",
    "no-var": "error",
    "object-shorthand": "error",
    "prefer-template": "error",
    "prefer-arrow-callback": "error"
  },
  "globals": {
    "KAGAMI": "readonly"
  }
}
```

### è‡ªå‹•åŒ–ãƒ„ãƒ¼ãƒ«è¨­å®š

```javascript
// build-tools/code-quality-checker.js
class CodeQualityChecker {
    static async checkFile(filePath) {
        const issues = [];
        const content = await this.readFile(filePath);
        
        // è¤‡é›‘åº¦ãƒã‚§ãƒƒã‚¯
        issues.push(...this.checkComplexity(content));
        
        // å‘½åè¦å‰‡ãƒã‚§ãƒƒã‚¯
        issues.push(...this.checkNamingConventions(content));
        
        // ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒã‚§ãƒƒã‚¯
        issues.push(...this.checkSecurity(content));
        
        // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒã‚§ãƒƒã‚¯
        issues.push(...this.checkPerformance(content));
        
        return issues;
    }
    
    static checkComplexity(content) {
        const issues = [];
        const lines = content.split('\n');
        
        // é–¢æ•°ã®é•·ã•ãƒã‚§ãƒƒã‚¯
        let functionStart = -1;
        let braceCount = 0;
        
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            
            if (line.includes('function') || line.includes('=>')) {
                functionStart = i;
                braceCount = 0;
            }
            
            braceCount += (line.match(/\{/g) || []).length;
            braceCount -= (line.match(/\}/g) || []).length;
            
            if (functionStart >= 0 && braceCount === 0) {
                const functionLength = i - functionStart;
                if (functionLength > 50) {
                    issues.push({
                        type: 'complexity',
                        message: 'é–¢æ•°ãŒé•·ã™ãã¾ã™ï¼ˆ50è¡Œè¶…éï¼‰',
                        line: functionStart + 1,
                        severity: 'warning'
                    });
                }
                functionStart = -1;
            }
        }
        
        return issues;
    }
    
    static checkNamingConventions(content) {
        const issues = [];
        
        // camelCaseå¤‰æ•°ãƒã‚§ãƒƒã‚¯
        const variableRegex = /(?:const|let|var)\s+([a-zA-Z_$][a-zA-Z0-9_$]*)/g;
        let match;
        
        while ((match = variableRegex.exec(content)) !== null) {
            const variableName = match[1];
            
            if (!/^[a-z][a-zA-Z0-9]*$/.test(variableName) && !/^[A-Z_][A-Z0-9_]*$/.test(variableName)) {
                issues.push({
                    type: 'naming',
                    message: `å¤‰æ•°åãŒcamelCaseã¾ãŸã¯UPPER_SNAKE_CASEã«å¾“ã£ã¦ã„ã¾ã›ã‚“: ${variableName}`,
                    severity: 'error'
                });
            }
        }
        
        return issues;
    }
    
    static checkSecurity(content) {
        const issues = [];
        const securityPatterns = [
            { pattern: /eval\(/, message: 'eval()ã®ä½¿ç”¨ã¯é¿ã‘ã¦ãã ã•ã„' },
            { pattern: /innerHTML\s*=/, message: 'innerHTMLä½¿ç”¨æ™‚ã¯ã‚µãƒ‹ã‚¿ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ç¢ºèªã—ã¦ãã ã•ã„' },
            { pattern: /document\.write/, message: 'document.write()ã®ä½¿ç”¨ã¯é¿ã‘ã¦ãã ã•ã„' },
            { pattern: /window\.location\.href\s*=/, message: 'URLãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆæ™‚ã¯æ¤œè¨¼ã‚’è¡Œã£ã¦ãã ã•ã„' }
        ];
        
        for (const { pattern, message } of securityPatterns) {
            if (pattern.test(content)) {
                issues.push({
                    type: 'security',
                    message: message,
                    severity: 'warning'
                });
            }
        }
        
        return issues;
    }
    
    static checkPerformance(content) {
        const issues = [];
        const performancePatterns = [
            { pattern: /document\.querySelectorAll.*forEach/, message: 'NodeListã®åå¾©å‡¦ç†ã¯é…åˆ—ã«å¤‰æ›ã—ã¦ã‹ã‚‰è¡Œã£ã¦ãã ã•ã„' },
            { pattern: /setInterval\(.*,\s*[1-9]\d{0,2}\)/, message: 'çŸ­ã„é–“éš”ã®setIntervalã¯ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã«å½±éŸ¿ã—ã¾ã™' },
            { pattern: /\.innerHTML\s*\+=/, message: 'innerHTML+=ã¯åŠ¹ç‡ãŒæ‚ªã„ã§ã™ã€‚DocumentFragmentã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„' }
        ];
        
        for (const { pattern, message } of performancePatterns) {
            if (pattern.test(content)) {
                issues.push({
                    type: 'performance',
                    message: message,
                    severity: 'warning'
                });
            }
        }
        
        return issues;
    }
}
```

---

## ğŸ”„ ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°æŒ‡é‡

### æ®µéšçš„ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°

```javascript
// âœ… æ¨å¥¨ - æ®µéšçš„ãªæ”¹å–„ã‚¢ãƒ—ãƒ­ãƒ¼ãƒ
class RefactoringStrategy {
    static createLegacyWrapper(oldFunction, newFunction, options = {}) {
        const deprecationWarning = options.deprecationWarning || true;
        const removeInVersion = options.removeInVersion;
        
        return function(...args) {
            if (deprecationWarning && KAGAMI.config.debug) {
                console.warn(`âš ï¸ éæ¨å¥¨é–¢æ•°ã®ä½¿ç”¨: ${oldFunction.name}`, {
                    replacement: newFunction.name,
                    removeInVersion: removeInVersion,
                    stack: new Error().stack
                });
            }
            
            // ä½¿ç”¨é‡ã‚’è¿½è·¡
            KAGAMI.logger?.info('Legacy Function Usage', {
                function: oldFunction.name,
                replacement: newFunction.name
            });
            
            return newFunction.apply(this, args);
        };
    }
    
    static migrateApiUsage(oldApi, newApi, migrationMap) {
        const wrapper = {};
        
        for (const [oldMethod, newMethod] of Object.entries(migrationMap)) {
            wrapper[oldMethod] = function(...args) {
                console.warn(`âš ï¸ APIç§»è¡Œ: ${oldMethod} â†’ ${newMethod}`);
                return newApi[newMethod].apply(newApi, args);
            };
        }
        
        return wrapper;
    }
    
    static createFeatureFlag(featureName, defaultValue = false) {
        return {
            isEnabled: () => {
                const storage = localStorage.getItem(`kagami_feature_${featureName}`);
                if (storage !== null) {
                    return JSON.parse(storage);
                }
                return KAGAMI.config.features?.[featureName] ?? defaultValue;
            },
            
            enable: () => {
                localStorage.setItem(`kagami_feature_${featureName}`, 'true');
            },
            
            disable: () => {
                localStorage.setItem(`kagami_feature_${featureName}`, 'false');
            }
        };
    }
}

// ä½¿ç”¨ä¾‹
const newFileUpload = new FileUploadModule();
const oldFileUpload = RefactoringStrategy.createLegacyWrapper(
    function uploadFile() { /* æ—§å®Ÿè£… */ },
    newFileUpload.upload.bind(newFileUpload),
    { removeInVersion: '2.0.0' }
);

// ãƒ•ã‚£ãƒ¼ãƒãƒ£ãƒ¼ãƒ•ãƒ©ã‚°ã®ä½¿ç”¨
const useNewDashboard = RefactoringStrategy.createFeatureFlag('new_dashboard', false);

if (useNewDashboard.isEnabled()) {
    // æ–°ã—ã„ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰
    loadNewDashboard();
} else {
    // å¾“æ¥ã®ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰
    loadLegacyDashboard();
}
```

### ä¾å­˜é–¢ä¿‚ç®¡ç†

```javascript
// âœ… æ¨å¥¨ - ä¾å­˜é–¢ä¿‚ã®å¯è¦–åŒ–ã¨ç®¡ç†
class DependencyManager {
    constructor() {
        this.dependencies = new Map();
        this.circular = new Set();
    }
    
    register(moduleName, dependencies = []) {
        this.dependencies.set(moduleName, dependencies);
        this.detectCircularDependencies();
    }
    
    detectCircularDependencies() {
        const visited = new Set();
        const recursionStack = new Set();
        
        const dfs = (module) => {
            if (recursionStack.has(module)) {
                this.circular.add(module);
                return true;
            }
            
            if (visited.has(module)) {
                return false;
            }
            
            visited.add(module);
            recursionStack.add(module);
            
            const deps = this.dependencies.get(module) || [];
            for (const dep of deps) {
                if (dfs(dep)) {
                    return true;
                }
            }
            
            recursionStack.delete(module);
            return false;
        };
        
        for (const module of this.dependencies.keys()) {
            if (!visited.has(module)) {
                dfs(module);
            }
        }
        
        if (this.circular.size > 0) {
            console.error('å¾ªç’°ä¾å­˜ã‚’æ¤œå‡º:', Array.from(this.circular));
        }
    }
    
    getLoadOrder() {
        const sorted = [];
        const visited = new Set();
        
        const visit = (module) => {
            if (visited.has(module)) return;
            
            visited.add(module);
            const deps = this.dependencies.get(module) || [];
            
            for (const dep of deps) {
                visit(dep);
            }
            
            sorted.push(module);
        };
        
        for (const module of this.dependencies.keys()) {
            visit(module);
        }
        
        return sorted;
    }
}
```

---

## ğŸ“ˆ ä¿å®ˆæ€§ãƒ¡ãƒˆãƒªã‚¯ã‚¹

### ã‚³ãƒ¼ãƒ‰å“è³ªæ¸¬å®š

```javascript
// âœ… æ¨å¥¨ - ä¿å®ˆæ€§ã®å®šé‡çš„æ¸¬å®š
class MaintenabilityMetrics {
    static analyzeFile(content, filePath) {
        const metrics = {
            file: filePath,
            lines: this.countLines(content),
            functions: this.countFunctions(content),
            complexity: this.calculateComplexity(content),
            duplications: this.detectDuplications(content),
            dependencies: this.analyzeDependencies(content),
            testCoverage: this.estimateTestCoverage(content),
            documentation: this.analyzeDocumentation(content)
        };
        
        metrics.maintainabilityIndex = this.calculateMaintainabilityIndex(metrics);
        return metrics;
    }
    
    static countLines(content) {
        const lines = content.split('\n');
        return {
            total: lines.length,
            code: lines.filter(line => line.trim() && !line.trim().startsWith('//')).length,
            comments: lines.filter(line => line.trim().startsWith('//')).length,
            blank: lines.filter(line => !line.trim()).length
        };
    }
    
    static calculateComplexity(content) {
        // ã‚µã‚¤ã‚¯ãƒ­ãƒãƒ†ã‚£ãƒƒã‚¯è¤‡é›‘åº¦ã®è¨ˆç®—
        const complexityKeywords = [
            'if', 'else', 'for', 'while', 'do', 'switch', 'case',
            'catch', 'finally', '&&', '||', '?'
        ];
        
        let complexity = 1; // åŸºæœ¬è¤‡é›‘åº¦
        
        for (const keyword of complexityKeywords) {
            const regex = new RegExp(`\\b${keyword}\\b`, 'g');
            const matches = content.match(regex);
            if (matches) {
                complexity += matches.length;
            }
        }
        
        return complexity;
    }
    
    static detectDuplications(content) {
        const lines = content.split('\n');
        const duplications = [];
        const lineMap = new Map();
        
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i].trim();
            if (line.length < 5) continue; // çŸ­ã„è¡Œã¯é™¤å¤–
            
            if (lineMap.has(line)) {
                lineMap.get(line).push(i + 1);
            } else {
                lineMap.set(line, [i + 1]);
            }
        }
        
        for (const [line, lineNumbers] of lineMap) {
            if (lineNumbers.length > 1) {
                duplications.push({
                    content: line,
                    lines: lineNumbers,
                    count: lineNumbers.length
                });
            }
        }
        
        return duplications;
    }
    
    static analyzeDependencies(content) {
        const imports = [];
        const exports = [];
        
        // importæ–‡ã®è§£æ
        const importRegex = /import\s+.*\s+from\s+['"]([^'"]+)['"]/g;
        let match;
        while ((match = importRegex.exec(content)) !== null) {
            imports.push(match[1]);
        }
        
        // requireæ–‡ã®è§£æ
        const requireRegex = /require\(['"]([^'"]+)['"]\)/g;
        while ((match = requireRegex.exec(content)) !== null) {
            imports.push(match[1]);
        }
        
        // exportæ–‡ã®è§£æ
        const exportRegex = /export\s+(?:default\s+)?(\w+)/g;
        while ((match = exportRegex.exec(content)) !== null) {
            exports.push(match[1]);
        }
        
        return {
            imports: imports,
            exports: exports,
            fanIn: imports.length,
            fanOut: exports.length
        };
    }
    
    static estimateTestCoverage(content) {
        // ãƒ†ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‹ã©ã†ã‹ã®åˆ¤å®š
        const isTestFile = /\.(test|spec)\.js$/.test(content) || 
                          content.includes('describe(') || 
                          content.includes('it(') ||
                          content.includes('test(');
        
        if (isTestFile) {
            return 100; // ãƒ†ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«è‡ªä½“
        }
        
        // é–¢æ•°ã®æ•°ã¨ãƒ†ã‚¹ãƒˆã®æ¨å®š
        const functionCount = this.countFunctions(content).total;
        const testableComplexity = this.calculateComplexity(content);
        
        // ç°¡æ˜“çš„ãªæ¨å®šï¼ˆå®Ÿéš›ã«ã¯ãƒ†ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‚’è§£æã™ã‚‹å¿…è¦ãŒã‚ã‚‹ï¼‰
        return Math.max(0, 100 - (testableComplexity - functionCount) * 10);
    }
    
    static countFunctions(content) {
        const functionRegex = /function\s+\w+|=>\s*{|class\s+\w+/g;
        const matches = content.match(functionRegex) || [];
        
        return {
            total: matches.length,
            average_length: this.calculateAverageFunctionLength(content)
        };
    }
    
    static calculateAverageFunctionLength(content) {
        const lines = content.split('\n');
        const functionStarts = [];
        const functionLengths = [];
        
        for (let i = 0; i < lines.length; i++) {
            if (/function\s+\w+|=>\s*{|class\s+\w+/.test(lines[i])) {
                functionStarts.push(i);
            }
        }
        
        for (let i = 0; i < functionStarts.length; i++) {
            const start = functionStarts[i];
            const end = functionStarts[i + 1] || lines.length;
            functionLengths.push(end - start);
        }
        
        return functionLengths.length > 0 ? 
               functionLengths.reduce((a, b) => a + b, 0) / functionLengths.length : 0;
    }
    
    static analyzeDocumentation(content) {
        const lines = content.split('\n');
        const docLines = lines.filter(line => 
            line.trim().startsWith('/**') || 
            line.trim().startsWith('*') || 
            line.trim().startsWith('///')
        ).length;
        
        const codeLines = lines.filter(line => 
            line.trim() && !line.trim().startsWith('//')
        ).length;
        
        return {
            documentation_ratio: codeLines > 0 ? docLines / codeLines : 0,
            has_jsdoc: content.includes('/**'),
            has_comments: content.includes('//')
        };
    }
    
    static calculateMaintainabilityIndex(metrics) {
        // Microsoftå¼ Maintainability Index ã®ç°¡æ˜“ç‰ˆ
        const complexity = metrics.complexity;
        const linesOfCode = metrics.lines.code;
        const halsteadVolume = Math.log2(linesOfCode) * 10; // ç°¡æ˜“è¨ˆç®—
        
        let index = 171 - 5.2 * Math.log(halsteadVolume) - 0.23 * complexity - 16.2 * Math.log(linesOfCode);
        
        // è£œæ­£è¦ç´ 
        if (metrics.testCoverage > 80) index += 10;
        if (metrics.documentation.documentation_ratio > 0.2) index += 5;
        if (metrics.duplications.length === 0) index += 5;
        
        return Math.max(0, Math.min(100, index));
    }
    
    static generateReport(metrics) {
        const report = {
            summary: {
                total_files: metrics.length,
                average_maintainability: metrics.reduce((sum, m) => sum + m.maintainabilityIndex, 0) / metrics.length,
                high_complexity_files: metrics.filter(m => m.complexity > 10).length,
                low_test_coverage_files: metrics.filter(m => m.testCoverage < 70).length
            },
            recommendations: []
        };
        
        // æ¨å¥¨äº‹é …ã®ç”Ÿæˆ
        for (const metric of metrics) {
            if (metric.complexity > 15) {
                report.recommendations.push({
                    file: metric.file,
                    type: 'complexity',
                    message: 'é–¢æ•°ã®è¤‡é›‘åº¦ãŒé«˜ã™ãã¾ã™ã€‚ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ã‚’æ¤œè¨ã—ã¦ãã ã•ã„ã€‚',
                    priority: 'high'
                });
            }
            
            if (metric.functions.average_length > 30) {
                report.recommendations.push({
                    file: metric.file,
                    type: 'function_length',
                    message: 'é–¢æ•°ã®é•·ã•ãŒé•·ã™ãã¾ã™ã€‚åˆ†å‰²ã‚’æ¤œè¨ã—ã¦ãã ã•ã„ã€‚',
                    priority: 'medium'
                });
            }
            
            if (metric.duplications.length > 5) {
                report.recommendations.push({
                    file: metric.file,
                    type: 'duplication',
                    message: 'ã‚³ãƒ¼ãƒ‰ã®é‡è¤‡ãŒå¤šãæ¤œå‡ºã•ã‚Œã¾ã—ãŸã€‚å…±é€šåŒ–ã‚’æ¤œè¨ã—ã¦ãã ã•ã„ã€‚',
                    priority: 'medium'
                });
            }
        }
        
        return report;
    }
}

// ä½¿ç”¨ä¾‹
const projectMetrics = [];
const files = ['app.js', 'data-input.js', 'ai-faq.js']; // å®Ÿéš›ã«ã¯ãƒ•ã‚¡ã‚¤ãƒ«ä¸€è¦§ã‚’å–å¾—

for (const file of files) {
    const content = await fetch(file).then(r => r.text());
    const metrics = MaintenabilityMetrics.analyzeFile(content, file);
    projectMetrics.push(metrics);
}

const report = MaintenabilityMetrics.generateReport(projectMetrics);
console.log('ğŸ” ä¿å®ˆæ€§ãƒ¬ãƒãƒ¼ãƒˆ:', report);
```

---

**ğŸ“š é–¢é€£ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ**
- [ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆãƒ©ã‚¤ãƒ–ãƒ©ãƒª](component-library.md)
- [API ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹](api-reference.md)
- [ãƒ‡ã‚¶ã‚¤ãƒ³ã‚·ã‚¹ãƒ†ãƒ ](design-system.md)

**ğŸ“ ãŠå•ã„åˆã‚ã›**  
KAGAMIé–‹ç™ºãƒãƒ¼ãƒ : dev@kagami.jp

---

**ğŸš€ v2.0 æ–°æ©Ÿèƒ½**
- é«˜åº¦ãªè¨­è¨ˆãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆãƒ¢ã‚¸ãƒ¥ãƒ©ãƒ¼è¨­è¨ˆã€ä¾å­˜æ€§æ³¨å…¥ã€è¦³å¯Ÿè€…ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰
- ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–ï¼ˆä»®æƒ³åŒ–ã€ãƒ¡ãƒ¢åŒ–ã€ãƒãƒƒãƒå‡¦ç†ï¼‰
- ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å¼·åŒ–ï¼ˆå…¥åŠ›å€¤æ¤œè¨¼ã€XSSå¯¾ç­–ã€CSPå¯¾å¿œï¼‰
- ãƒ†ã‚¹ãƒˆæˆ¦ç•¥ï¼ˆãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆã€E2Eè‡ªå‹•åŒ–å¯¾å¿œï¼‰
- æ§‹é€ åŒ–ãƒ­ã‚°ã¨ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ç›£è¦–
- é–‹ç™ºãƒ„ãƒ¼ãƒ«é€£æºï¼ˆESLintã€Prettierã€å“è³ªãƒã‚§ãƒƒã‚«ãƒ¼ï¼‰
- ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°æŒ‡é‡ï¼ˆæ®µéšçš„æ”¹å–„ã€ä¾å­˜é–¢ä¿‚ç®¡ç†ï¼‰
- ä¿å®ˆæ€§ãƒ¡ãƒˆãƒªã‚¯ã‚¹ï¼ˆå®šé‡çš„å“è³ªæ¸¬å®šã€æ”¹å–„ææ¡ˆï¼‰

*æœ€çµ‚æ›´æ–°: 2024å¹´12æœˆ19æ—¥ v2.0* 